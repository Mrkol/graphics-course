# Тон-маппинг

В данном задании вам предстоит развить свои навыки GPGPU программирования, при желании познакомится с теорией цвета и добавить в ваш рендерер тон-маппинг.

## Перед началом

1. Скопируйте в эту папку любой рендерер уже рисующий что-то, аналогично предыдущим заданиям.
   В идеале он должен включать в себя все релевантные предыдущие домашки.
2. По возможности прочитайте [краткое объяснение](https://computergraphics.stackexchange.com/a/10318) того, что такое цветовые пространства, гамма-коррекция и тон-маппинг.

## Задание

#### Шаг 1

Поменяйте ваш рендерер чтобы он
1. использовал картинку формата `B10G11R11_UFLOAT` при рендеринге;
2. переносил контент этой картинки в `R8G8B8`-бэкбуфер при помощи пиксельного шейдера, просто квантующего диапазон $[0, 1]$ на $256$ значений и ограничивающего значения больше $1$ (нужно ли вообще писать какой-то код чтобы получить такое поведение в шейддере?).

В данном контексте картинку формата `B10G11R11_UFLOAT` будем называть HDR-изображением (high dynamic range), бэкбуфер LDR-изображением (low dynamic range), а шейдер переносящий его контент в бэкбуфер будем называть шейдером пост-обработки.

#### Шаг 2

Добавьте в шейдер пост-обработки наивный метод уравнивания гистограмм из раздела 4.3 следующей [статьи](https://graphics.cs.yale.edu/sites/default/files/1997tvcg_hdr_tonemapping.pdf). Для этого:

1. напишите компьют-шейдер который посчитает минимум и максимум уровней освещённости в исходном изображении;
2. напишите компьют-шейдер, который посчитает гистограмму плотности распределения логарифмов уровней освещённости пикселей HDR-изображения с $\approx 100$ уровнями квантизации, распределёнными равномерно от минимума до максимума;
3. напишите компьют-шейддер, который превратит эту гистограмму в функцию распределения;
4. поменяйте шейдер пост-обработки чтобы он применял к яркости пикселя преобразование основанное на функции распределения.

За использование shared memory для накопления локальных результатов в рамках группы тредов полагаются дополнительные баллы.
Однако лучше реализовать оба варианта и сравнить профайлером время исполнения, использовать shared memory не всегда быстрее чем не использовать.
Если в вашем приложении будет возможность включить/отключить shared memory (например при помощи ImGui) и сравнить результаты, это даст ещё больше баллов.

Подумайте, что в здесь имеется в виду под яркостью.
Есть ли у яркости понятное представление в цветовой модели RGB?
А в других цветовых моделях?
Подсказка: это **не** максимум из значений каналов.

## Бонусный уровень

Прочитайте [статью](https://scholar.google.com/scholar?cluster=3620574908359198509&hl=en&as_sdt=0,5) о более продвинутом уравнивании гистограмм и реализуйте описанный в ней метод.

## Полезные материалы

1. https://computergraphics.stackexchange.com/a/10318 &mdash; неплохое объяснение цветовых пространств "на пальцах"
2. https://graphics.cs.yale.edu/sites/default/files/1997tvcg_hdr_tonemapping.pdf &mdash; тон-маппинг при помощи уравнивания гистограмм
3. https://scholar.google.com/scholar?cluster=3620574908359198509&hl=en&as_sdt=0,5 &mdash; более продвинутый метод уравнивания гистограмм
