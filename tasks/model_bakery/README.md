# Запекалка моделей

В данном задании вам предстоит познакомиться с пайплайном работы с 3D-моделями.

Для этого мы будем использовать открытый формат хранения моделей [glTF](https://github.com/KhronosGroup/glTF), а также его расширение [EXT_meshopt_compression](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md).
Чтобы не заниматься парсингом и валидацией джейсонов в ручную, мы используем библиотеку [tinygltf](https://github.com/syoyo/tinygltf), предоставляющую удобный интерфейс для получения данных из glTF моделей.

С этим форматом вы уже могли столкнуться, если пробовали читать код семпла [shadowmap](/samples/shadowmap/).
Если вдруг вы изучали его особенно пристально, то могли заметить, что в классе [SceneManager](/common/scene/SceneManager.cpp) реализована достаточно длинная процедура перекодирования бинарных данных вершин и индексов из (почти) произвольного glTF-файла в удобный для рендеринга формат.
Такая процедура перекодирования, разумеется, занимает не нулевое время, и в крупной игре пагубно сказалась бы на времени загрузки карт или уровней.
Однако если вы пиете не игру, а какой-то инструмент для работы с произвольными моделями, то другого выхода у вас нет.

Вместо этого подхода в данном задании предлагается реализовать более разумный для игр подход: запекание моделей.
То есть просто заранее перекодировать модель в удобный для рендеринга формат отдельным приложением-печкой, а в приложении-рендерере загружать бинарные данные напрямую на GPU.

## Перед началом

 1. Откройте какую-нибудь простую модель текстовой версии формата glTF, например [SimpleMeshes.gltf](/resources/scenes/SimpleMeshes/glTF/SimpleMeshes.gltf), и разберитесь, что там написано при помощи [спецификации](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html).
 2. Вспомните, что такое [октаэдральное кодирование нормалей](https://knarkowicz.wordpress.com/2014/04/16/octahedron-normal-vector-encoding/).

## Задание

#### Шаг 1

Используя [tinygltf](https://github.com/syoyo/tinygltf), напишите приложение-запекалку, которое сможет перекодировать модели из папки [scenes](/resources/scenes/) в описанный далее формат.

Во-первых, все аттрибуты каждой вершины должно идти в буфере подряд.
Во-вторых, нормали и касательные должны быть октаэдрально закодированы.
Итого каждая вершина должна занимать 32 байта с учётом выравнивания и выглядеть в бинарном файле идущем с джейсоном модели следующим образом:
| Сдвиг (байты) | Содержимое    |
| ------------- | ------------- |
| 0  | Координаты, 3 по float32 |
| 12 | Октаэдрально закодированная нормаль, 4 байта |
| 16 | Текстурные координаты, 2 по float32 |
| 24 | Октаэдрально закодированная касательная, 4 байта |
| 28 | Паддинг, 4 байта |

Для октаэдрального кодирования нормалей используйте расширение glTF [EXT_meshopt_compression](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md).

#### Шаг 2

Напишите в [SceneManager](/common/scene/SceneManager.hpp) новый (чтобы не сломать семплы) метод для загрузки моделей в сразу пригодном для рендеринга формате.
Этот метод должен напрямую загружать 2 половинки буфера glTF в вершинный и индексный буферы Этны соответственно.

Проверьте, что предоставленный семпл успешно рендерит вашу перекодированную модель.

## Бонусный уровень

Используя [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md), "упихайте" модель в 16 байт на вершину.
Для этого вам придётся в том числе поменять код семпла.

Отразилось ли это сжатие на итоговой картинке? Как? Почему?
