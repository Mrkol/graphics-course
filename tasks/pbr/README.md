# PBR

В данном задании вам предстоит познакомиться с PBR (physically based rendering, рендеринг, основанный на физике) и наконец-то добавить материалы в ваш рендерер, если вы конечно ещё этого не сделали.

## Перед началом

1. Скопируйте в эту папку любой рендерер уже рисующий что-то, аналогично предыдущим заданиям.
   В идеале он должен включать в себя все релевантные предыдущие домашки.
2. Вспомните материал занятия про PBR.


## Задание

#### Шаг 1

Добавьте в [SceneManager](/common/scene/SceneManager.hpp) абстракцию материала: графический шейдер вкупе с набором числовых констант и текстур, передаваемых в него при отрисовке, а также возможно дополнительная конфигурация графического пайплайна.
Вообще говоря система материалов должна быть достаточно обобщённой и набор параметров должен диктоваться конкретным шейдером, но в простейшем варианте скажем что у нас есть **лишь один шейдер** и набор его параметров фиксированный: текстуры базового цвета, шершавости, металличности и карты нормалей.

За более общие системы, конечно же, полагаются бонусные баллы.
Однако постарайтесь остаться в рамках разумного, например, добавьте ещё несколько шейдеров для более эффективной отрисовки не PBR моделей или элементов с константными параметрами, или же добавьте поддержку "двухсторонних" рендер элементов для которых отключается back face culling.

Каждому `RenderElement` должен соответствовать фиксированный материал.
Загрузите все эти данные из файла модели.
Если у модели не хватает каких-то параметров, либо используйте другую модель, либо сгенерируйте "заглушки" в печке или в рантайме.
Например, если у куска модедли константный параметр шершавости, создайте новую текстуру 1х1 пиксель залитую контентом соответствующим этой константе.
Текстуры эмиссивности пока что предлагается игнорировать (если вам конечно не нужны бонусные баллы).

Обратите внимание, что текстуры базового цвета и эмиссивности в glTF закодированы функцией перехода sRGB, а поэтому загружать их нужно в изображение формата `R8G8B8A8_SRGB`, чтобы вулкан автоматом за вас сделал обратное преобразование (так же известное как гамма-коррекция).
Текстура металличности/шершавости при этом закодирована линейно, а поэтому должна использовать формат `R8G8B8A8_UNORM`.

##### Методическая рекомендация

Для айдишников материалов и текстур используйте типы вроде `enum class SomeId : uint32_t { Invalid = ~uint32_t{0}; };` вместо обычных интов или указателей.
Это позволит вам никогда не запутаться, где у вас какой конкретно айдишник, и не передать случайно айди материала в функцию ожидающую айди текстуры.
Более того, это позволит хранить различные структуры в памяти более компактно чем если использовать указатели (4 байта против 8 + выравнивание), тем самым повышая эффективность кэшей CPU.
Наконец, используя айдишники и вектора с проверкой выхода за границы мы гарантированно избегаем мерзких багов с протухшими после пуш-бэка указателями.

#### Шаг 2

Добавьте в ваш основной шейдер сцены чтение параметров материала.
Нормали считывайте из карты нормалей в базисе образуемом вершинной нормалью, тангентом и битангентом, где последний вычисляйте согласно спецификации glTF.
Пока что не бегите вписывать в шейдер полноценный PBR, убедитесь что все текстуры успешно загрузились просто выводя их контент как цвет, а также убедитесь что текущее наивное освещение работает с использованием карты нормалей.

Если у вас есть G-буфер, добавьте в него дополнительную информацию о материале и записывайте её туда в шейдере сцены.

Если у вас используется мульти-дро, то вам придётся частично отключить его, делая отдельный вызов отрисовки для каждого материала.
Побороть эту проблему в будущем нам поможет техника bindless.

#### Шаг 3

Прочитайте внимательно раздел [B.2](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#material-structure) спецификации glTF.
Не забудьте пройтись по ссылкам на статьи.

Поменяйте код вычисления освещения так, чтобы он использовал микрофасетную модель GGX описанную в спецификации glTF с параметрами, считанными из материала.

Чтобы показывать хоть что-то в отражениях на металлических поверхностях, добавьте в ваше приложение скайбокс и используйте его и для отражений, и в качестве фона всей сцены (для этого можно нарисовать квадрат на весь экран с максимально удалённым Z и использовать нашу любимую трассировку лучей).

## Бонусный уровень

Прочитайте про [visibility buffer](https://steps3d.narod.ru/tutorials2/visibility-buffer.html) (можно даже [оригинальную статью](https://jcgt.org/published/0002/02/04/)) и замените ваш G-буфер на него.

## Полезные материалы

1. https://www.youtube.com/watch?v=gya7x9H3mV0 &mdash; неплохая лекция по PBR
2. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#materials &mdash; формат хранения материалов в glTF
3. https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#material-structure &mdash; предполагаемый моделями glTF метод PBR-освещения
4. https://www.graphics.cornell.edu/~westin/pubs/TorranceSparrowJOSA1967.pdf &mdash; микрофасетная модель
5. https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf &mdash; распределение GGX
6. https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=183db641ff80ff21234040ccce884cb06227dad4 &mdash; приближение Шлика для коэффициента Френеля
7. https://jcgt.org/published/0002/02/04/ &mdash; visibility buffer
8. https://steps3d.narod.ru/tutorials2/visibility-buffer.html &mdash; про visibility buffer от Алексея Викторовича
