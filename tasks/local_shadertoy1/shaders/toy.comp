#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;


layout(push_constant) uniform params 
{
  uint resolution_x;
  uint resolution_y;
  float mouse_x;
  float mouse_y;
} params_t;

vec2 iResolution;
vec2 iMouse;

const vec3  eye      = vec3 ( 0, 0, 3 );
const vec3  light    = vec3  ( 0.0, 3.0, 5.0 );
const int   maxSteps = 70;
const float eps      = 0.01;

// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

vec3 rotateZ(vec3 v, float theta) {
    float c = cos(theta);
    float s = sin(theta);
    
    mat4 rotMat = mat4 (
        vec4 (c, -s, 0, 0),
        vec4 (s,  c, 0, 0),
        vec4 (0,  0, 1, 0),
        vec4 (0,  0, 0, 1)
    );
    return (rotMat * vec4 (v, 1)).xyz;
}

float dTriPrism(vec3 p, vec2 h) {
    vec3 q = abs(p);
    
    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);
}

float dSerpinskiyInner(vec3 p, vec2 h, float level) {
   vec3 q1 = rotateZ(p,  60.0 * 3.14159265359 / 180.0);
   float innerPrism = dTriPrism (q1, vec2 ( pow ( 0.5, level ) * h.x, h.y + 0.1 ));
   return -innerPrism;
}



float dSerpinskiyUnit1 (vec3 p, vec2 h, float level) {
    vec3 m1 = vec3 ( 0.87 / level, 0.5 / level, 0);
    vec3 m2 = vec3 (-0.87 / level, 0.5 / level, 0);
    vec3 m3 = vec3 ( 0.0 ,        -1.0 / level, 0);
    
    vec3 q1 = p + m1;
    vec3 q2 = p + m2;
    vec3 q3 = p + m3;
    
    float t1 = dSerpinskiyInner(q1, h, level + 1.0);
    float t2 = dSerpinskiyInner(q2, h, level + 1.0);
    float t3 = dSerpinskiyInner(q3, h, level + 1.0);
    
    float res = max ( max (t1, t2), t3 );
    
    return res;
}

float dSerpinskiyUnit (vec3 p, vec2 h, float level) {
    vec3 m1 = vec3 ( 0.87 / level, 0.5 / level, 0);
    vec3 m2 = vec3 (-0.87 / level, 0.5 / level, 0);
    vec3 m3 = vec3 ( 0.0 ,        -1.0 / level, 0);
    
    vec3 q1 = p + m1;
    vec3 q2 = p + m2;
    vec3 q3 = p + m3;
    
    float t1 = dSerpinskiyInner(q1, h, level + 1.0);
    float t2 = dSerpinskiyInner(q2, h, level + 1.0);
    float t3 = dSerpinskiyInner(q3, h, level + 1.0);
    
    float res = max ( max (t1, t2), t3 );
    
    if (level != 0.0) {
        float d1 = dSerpinskiyUnit1 (q1, h, level + 1.0);
        float d2 = dSerpinskiyUnit1 (q2, h, level + 1.0);
        float d3 = dSerpinskiyUnit1 (q3, h, level + 1.0);
        
        float dres = max ( max (d1, d2), d3 );
        
        return max (res, dres);
        
    }
    
    return res;
}

float dSerpinskiy ( vec3 p, vec2 h, float level ) {
    float mainPrism  = dTriPrism       (p, h);
    
    float innerPrism = dSerpinskiyInner(p, h, level - 1.0);
    
    float units      = dSerpinskiyUnit (p, h, level - 1.0);
    
    float res = max ( max ( mainPrism, innerPrism ), units );
    
    return res;
}

float length8 ( in vec2 p )
{
    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ), 1.0/ 8.0 );
}

float length8 ( in vec3 p )
{
    return pow ( pow ( p.x, 8.0 ) + pow ( p.y, 8.0 ) + pow ( p.z, 8.0 ), 1.0/ 8.0 );
}


float dTorus ( vec3 p, vec2 t )
{
	vec2	q = vec2 ( length8 ( p.xz ) - t.x, p.y );
	
	return length ( q ) - t.y;
}

float smin ( float a, float b, float k )
{
	float res = exp ( -k*a ) + exp ( -k*b );
	return -log ( res ) / k;
}

float sdf ( in vec3 p )
{
	return dTorus ( p, vec2 ( 0.73, 0.5 ) );
}

float sdf ( in vec3 p, in mat3 m )
{
   vec3 q = m * p;
	return dSerpinskiy (q, vec2 (2, 0.1), 2.0 ) ;
}

vec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )
{
	vec3	p         = from;
	float	totalDist = 0.0;
	
	hit = false;
	
	for ( int steps = 0; steps < maxSteps; steps++ )
	{
		float	dist = sdf ( p, m );
        
		if ( dist < 0.01 )
		{
			hit = true;
			break;
		}
		
		totalDist += dist;
		
		if ( totalDist > 10.0 )
			break;
			
		p += dist * dir;
	}
	
	return p;
}

vec3 generateNormal ( vec3 z, float d, in mat3 m )
{
    float e   = max (d * 0.5, eps );
    float dx1 = sdf(z + vec3(e, 0, 0), m);
    float dx2 = sdf(z - vec3(e, 0, 0), m);
    float dy1 = sdf(z + vec3(0, e, 0), m);
    float dy2 = sdf(z - vec3(0, e, 0), m);
    float dz1 = sdf(z + vec3(0, 0, e), m);
    float dz2 = sdf(z - vec3(0, 0, e), m);
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

const float roughness = 0.2;
const vec3  r0   = vec3 ( 1.0, 0.92, 0.23 );
const vec3  clr  = vec3 ( 0.7, 0.1, 0.1 );
const float gamma = 2.2;
const float pi    = 3.1415926;
const float FDiel = 0.04;		// Fresnel for dielectrics

vec3 fresnel ( in vec3 f0, in float product )
{
	product = clamp ( product, 0.0, 1.0 );		// saturate
	
	return mix ( f0, vec3 (1.0), pow(1.0 - product, 5.0) );
}

float D_blinn(in float roughness, in float NdH)
{
    float m = roughness * roughness;
    float m2 = m * m;
    float n = 2.0 / m2 - 2.0;
    return (n + 2.0) / (2.0 * pi) * pow(NdH, n);
}

float D_beckmann ( in float roughness, in float NdH )
{
	float m    = roughness * roughness;
	float m2   = m * m;
	float NdH2 = NdH * NdH;
	
	return exp( (NdH2 - 1.0) / (m2 * NdH2) ) / (pi * m2 * NdH2 * NdH2);
}

float D_GGX ( in float roughness, in float NdH )
{
	float m  = roughness * roughness;
	float m2 = m * m;
	float NdH2 = NdH * NdH;
	float d  = (m2 - 1.0) * NdH2 + 1.0;
	
	return m2 / (pi * d * d);
}

float G_schlick ( in float roughness, in float nv, in float nl )
{
    float k = roughness * roughness * 0.5;
    float V = nv * (1.0 - k) + k;
    float L = nl * (1.0 - k) + k;
	
    return 0.25 / (V * L);
}

float G_neumann ( in float nl, in float nv )
{
	return nl * nv / max ( nl, nv );
}

float G_klemen ( in float nl, in float nv, in float vh )
{
	return nl * nv / (vh * vh );
}

float G_default ( in float nl, in float nh, in float nv, in float vh )
{
	return min ( 1.0, min ( 2.0*nh*nv/vh, 2.0*nh*nl/vh ) );
}

vec4 cookTorrance ( in vec3 p, in vec3 n, in vec3 l, in vec3 v )
{
  vec3  h    = normalize ( l + v );
	float nh   = dot (n, h);
	float nv   = dot (n, v);
	float nl   = dot (n, l);
	float vh   = dot (v, h);
    float metallness = 1.0;
    vec3  base  = pow ( clr, vec3 ( gamma ) );
    vec3  F0    = mix ( vec3(FDiel), clr, metallness );
	
			// compute Beckman
   	float d = D_beckmann ( roughness, nh );

            // compute Fresnel
    vec3 f = fresnel ( F0, nv );
	
            // default G
    float g = G_default ( nl, nh, nv, vh );
	
			// resulting color
	vec3  ct   = f*(0.25 * d * g / nv);
	vec3  diff = max(nl, 0.0) * ( vec3 ( 1.0 ) - f ) / pi;
	float ks   = 0.5;

	return vec4 ( pow ( diff * base + ks * ct, vec3 ( 1.0 / gamma ) ), 1.0 );
}

void main()
{
  iResolution = vec2(params_t.resolution_x, params_t.resolution_y);
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  bool hit;
  vec2 mouse = vec2(params_t.mouse_x / iResolution.x - 0.5, params_t.mouse_y / iResolution.y - 0.5);
  mat3 m     = rotateX ( 6.0*mouse.y ) * rotateY ( 6.0*mouse.x);
  vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;
  vec2 uv_cur    = scale * ( uv/iResolution.xy - vec2 ( 0.5 ) );
	vec3 dir   = normalize ( vec3 ( uv_cur, 0 ) - eye );
  vec4 color = vec4 ( 0, 0, 0, 1 );
  vec3 p     = trace ( eye, dir, hit, m );

  if ( hit )
	{
		vec3  l  = normalize        ( light - p );
    vec3  v  = normalize        ( eye - p );
		vec3  n  = generateNormal   ( p, 0.001, m );
		float nl = max ( 0.0, dot ( n, l ) );
    vec3  h  = normalize ( l + v );
    float hn = max ( 0.0, dot ( h, n ) );
    float sp = pow ( hn, 150.0 );
		
    color = cookTorrance ( p, n, l, v );
	} 

  if (uv.x < iResolution.x && uv.y < iResolution.y)
    imageStore(resultImage, uv, color);
}
