#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform Params {
  uvec2 resolution;
  vec2 mouse_pos;
  float time;
} params;

const vec3  eye      = vec3 ( 0, 0, 3 );
const vec3  light    = vec3  ( 0.0, 3.0, 5.0 );
const int   maxSteps = 70;
const float eps      = 0.01;
const float max_dist = 10.0;

float smoothUnion ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) - k*h*(1.0-h); 
}

float smoothSubtraction ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );
    return mix( d2, -d1, h ) + k*h*(1.0-h); 
}

float smoothIntersection ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );
    return mix( d2, d1, h ) + k*h*(1.0-h); 
}

mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0, 0),
        vec3(0, c, -s),
        vec3(0, s, c)
    );
}

mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c, 0, s),
        vec3(0, 1, 0),
        vec3(-s, 0, c)
    );
}

float dCylinder(vec3 p, float r, float h) {
    return max(length(p.xz) - r, abs(p.y) - h);
}

float dSphere ( vec3 p, in vec3 c, float r)
{
	return length ( p - c ) - r;
}

float sdf ( in vec3 p, in mat3 m )
{
   vec3 q = m * p;
   q *= 1.0;
   float len = 0.5 * abs(sin(params.time));
   float cylinder = dCylinder(q, 0.1 + 0.75 * len, 0.7 + len); 
   float noise = 0.025 * sin(20.0*q.z + 20.0*q.y - 20.0 * q.x + + params.time*20.0);
   float sphere_left = dSphere(q, vec3(0, -0.7 - len, 0), 0.4 + len) + noise;
   float sphere_right = dSphere(q, vec3(0, 0.7 + len, 0), 0.4 + len) + noise;
   return smoothUnion(sphere_right, smoothUnion(cylinder, sphere_left, 0.1), 0.1);
}

vec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )
{
	vec3 p = from;
	float totalDist = 0.0;
	
	hit = false;
	
	for ( int steps = 0; steps < maxSteps; steps++ )
	{
		float	dist = sdf ( p, m );
        
		if ( dist < eps )
		{
			hit = true;
			break;
		}
		
		totalDist += dist;
		
		if ( totalDist > max_dist )
			break;
			
		p += dist * dir;
	}
	
	return p;
}

vec3 generateNormal ( vec3 z, float d, in mat3 m )
{
    float e   = max (d * 0.5, eps );
    float dx1 = sdf(z + vec3(e, 0, 0), m);
    float dx2 = sdf(z - vec3(e, 0, 0), m);
    float dy1 = sdf(z + vec3(0, e, 0), m);
    float dy2 = sdf(z - vec3(0, e, 0), m);
    float dz1 = sdf(z + vec3(0, 0, e), m);
    float dz2 = sdf(z - vec3(0, 0, e), m);
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

void main()
{
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  
  if (uv.x >= params.resolution.x || uv.y >= params.resolution.y)
    return;
  
  vec2 fragCoord = vec2(uv);
  vec2 iResolution = vec2(params.resolution);
  float iTime = params.time;
  vec4 iMouse = vec4(params.mouse_pos, 0.0, 0.0);
  
  bool hit;
  vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, iMouse.z-.5);
  mat3 m = rotateX(6.0*mouse.y) * rotateY(6.0*mouse.x);
  vec2 scale = 9.0 * iResolution.xy / max(iResolution.x, iResolution.y);
  vec2 coord = scale * (fragCoord/iResolution.xy - vec2(0.5));
  vec3 dir = normalize(vec3(coord, 0) - eye);
  vec4 color = vec4(0, 0, 0, 1);
  vec3 p = trace(eye, dir, hit, m);
  
  if (hit)
  {
    vec3 l = normalize(light - p);
    vec3 v = normalize(eye - p);
    vec3 n = generateNormal(p, 0.001, m);
    float nl = max(0.0, dot(n, l));
    vec3 h = normalize(l + v);
    float hn = max(0.0, dot(h, n));
    float sp = pow(hn, 150.0);
    vec4 dop = vec4(nl) + sp + vec4(0.3);
    vec4 albedo = vec4(0.5, 0.5, 1, 1);
    color = albedo * dop;
  }
  
  color = pow(color, vec4(1.0 / 2.2));
  
  imageStore(resultImage, uv, color);
}