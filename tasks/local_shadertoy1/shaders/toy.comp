#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform params 
{
    uint resolution_x;
    uint resolution_y;
    float time;
} params_t;

vec2 iResolution;
float iTime;
vec3 eye = vec3(0, 0, 10);
vec3 light = vec3(4, 3, 5);
float ambient = 0.05;

vec3 yellow = vec3(1, 1, 0);
vec3 red = vec3(1, 0, 0);
vec3 black = vec3(0, 0, 0);

mat3 yaw(in float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return mat3(c, s, 0, -s, c, 0, 0, 0, 1);
}

mat3 pitch(in float angle){
    float c = cos(angle);
    float s = sin(angle);
    return mat3(1, 0, 0, 0, c, s, 0, -s, c);
}

mat3 roll(in float angle){
    float c = cos(angle);
    float s = sin(angle);
    return mat3(c, 0, s, 0, 1, 0, -s, 0, c);
}

int MAX_STEPS = 50;
float EPS = 0.01;


const vec3 center = vec3(3, 0, 0);
const float radius = 1.0;
float dSphere (in vec3 p) {
    mat3 rotation = yaw(iTime);
    p *= 2.0;
    p = rotation * p;
    p.z /= 2.0;
    p = p - center;
    return (length (p) - radius + 0.03 * sin(20.0 * p.y + iTime)) / 2.0;
}

vec2 getTexCoord(vec3 p){
    mat3 rotation = roll(iTime);
    p *= 2.0;
    p = rotation * p;
    p.z /= 2.0;
    p = p - center;
    
    return vec2(sin((p - center).x), cos((p - center).y));
}

float sdf (in vec3 p) {
    //return dSphere(transpose(yaw(iTime)) * p - vec3(1, 1, 1), vec3(0.0));
    return dSphere(p);
}

vec3 trace(in vec3 st, in vec3 dir, out bool hit) {
    vec3 p = st;
    hit = false;
    
    for(int i = 0; i < MAX_STEPS; i++) {
        float dist = sdf(p);
        p += dir * dist;
        
        if(dist < EPS) {
            hit = true;
            break;
        }
    }
    
    return p;
}

vec3 generateNormal ( vec3 z)
{
    float e   = 0.0001;
    float dx1 = sdf(z + vec3(e, 0, 0));
    float dx2 = sdf(z - vec3(e, 0, 0));
    float dy1 = sdf(z + vec3(0, e, 0));
    float dy2 = sdf(z - vec3(0, e, 0));
    float dz1 = sdf(z + vec3(0, 0, e));
    float dz2 = sdf(z - vec3(0, 0, e));
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

void main()
{
  iResolution = vec2(params_t.resolution_x, params_t.resolution_y);
  iTime = params_t.time;
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);

  bool hit;
  vec2 uv = fragCoord/iResolution.xy;
  uv = uv * 2.0 - 1.0;
  
  uv.x = uv.x * iResolution.x / iResolution.y;
  vec3 dir = normalize (vec3(uv, 0) - eye);
  
  vec3 dir2;
  float near = 1.0;
  float fov = 0.6;
  dir2.z = -near;
  dir2.y = near * tan(fov / 2.0) * uv.y;
  dir2.x = near * tan(fov / 2.0) * uv.x;
  dir2 = normalize(dir2);  
  dir2 = dir2;
  
  vec3 p = trace(eye, dir2, hit);
  vec3 color = vec3(0.0);
  
  if (hit) {
      vec3 ld = normalize (light - p);
      vec3 ed = normalize (eye - p);
      vec3 norm = generateNormal(p);
      vec3 h = normalize (ld + ed);
      float hn = max(0.0, dot(h, norm));
      float spec = pow(hn, 100.0);
      float difus = max(0.0, dot(norm, ld));
      float light = 0.3 * spec + 0.7 * difus + ambient;
      
      color = vec3(light);
  }

  if (fragCoord.x < iResolution.x && fragCoord.y < iResolution.y)
    imageStore(resultImage, fragCoord, vec4(color, 1));
}
