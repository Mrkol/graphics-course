#version 430

layout(local_size_x = 32, local_size_y = 16) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

const vec2 iResolution = vec2(1280, 720);
const float iTime = 2.0f;

// --- START SHADERTOY COPYPASTA ---
const float PI = 3.14159265359;

const vec3 background_color = vec3(0.3, 0.7, 0.9);
const float shape_tolerance = 1.0; // (0; inf) how smooth will shape transition be
const float color_mix_sharpness = 10.0; // (1; inf) how sharp will color transition
const float trefoil_size = 6.0; // how big the whole thing is
const float radius = 0.5;

struct sphere {
    vec3 center;
    float radius;
    vec3 color;
};


const int n_spheres = 24;
sphere spheres[n_spheres] = sphere[](
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),
    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),
    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0))
);

const bool metal_reflection = false;


struct light{
    vec3 position;
    float strength;
    vec3 color;
};

const int n_lights = 1;
light lights[n_lights] = light[](
    light(vec3(0, 0, -100.0), 10000.0, vec3(1, 1, 1))
);


float sphere_sdf(in vec3 point, in vec3 center, in float radius) {
    return length(point - center) - radius;
}

// Color weight field - determines how much of a shape's color should be used.
float sphere_cwf(in vec3 point, in vec3 center, in float radius) {
    return pow(color_mix_sharpness, radius - (length(point - center)));
}

float sdf(in vec3 point) {
    float sum = 0.0;
    for (int i = 0; i < n_spheres; ++i) {
        float dist = sphere_sdf(point, spheres[i].center, spheres[i].radius);
        sum += exp2(-dist / shape_tolerance);
    }
    return -shape_tolerance * log2(sum);
}

vec3 base_color(in vec3 point) {
    vec3 color_num = vec3(0, 0, 0);
    vec3 color_denom = vec3(0, 0, 0);
    for (int i = 0; i < n_spheres; ++i) {
        float cwf = sphere_cwf(point, spheres[i].center, spheres[i].radius);
        color_num += spheres[i].color * cwf;
        color_denom += cwf;
    }
    return color_num / color_denom;
}

bool traceRay(in vec3 ray, in vec3 pos, out vec3 impact_point) {
    while (true) {
        float dist = abs(sdf(pos));
    
        if (dist < 0.01) {
            impact_point = pos;
            return true;
        }
        
        if (dist > 100.0) {
            return false;
        }
        
        pos += ray * dist;
    }
}

vec3 grad(in vec3 point, in float delta) {
    vec3 dx = vec3(delta, 0, 0);
    vec3 dy = vec3(0, delta, 0);
    vec3 dz = vec3(0, 0, delta);
    float y0 = sdf(point);
    return (vec3(sdf(point+dx), sdf(point+dy), sdf(point+dz)) - vec3(y0, y0, y0)) / delta;
}


vec3 diffuse(in vec3 point, in vec3 base_color) {
    vec3 normal = normalize(grad(point, 0.0001));
    vec3 result = vec3(0, 0, 0);
    
    for (int i = 0; i < n_lights; ++i) {
        vec3 lightray = lights[i].position - point;
        float intensity = lights[i].strength / pow(length(lightray), 2.0);
        result += max(dot(normal, normalize(lightray)), 0.0) * intensity * lights[i].color;
    }
    result *= base_color;
    return result;
}

vec3 specular(in vec3 eye, in vec3 point, in vec3 base_color) {
    vec3 normal = normalize(grad(point, 0.0001));
    vec3 eye_ray = normalize(eye - point);
    vec3 result = vec3(0, 0, 0);
    
    for (int i = 0; i < n_lights; ++i) {
        vec3 lightray_refl = -reflect(lights[i].position - point, normal);
        float intensity = lights[i].strength / pow(length(lightray_refl), 2.0);
        float powered = pow(max(dot(eye_ray, normalize(lightray_refl)), 0.0), 20.0);
        result += powered * intensity * lights[i].color;
    }
    
    if (metal_reflection) {
        result *= base_color;
    }
    return result;
}

void positionSpheres() {
    for (int i = 0; i < n_spheres; ++i) {
        float t = iTime + PI * float(i) / float(n_spheres);
        spheres[i].center = vec3(trefoil_size * cos(3.0 * t) * sin(t) + sin(2.0 * t) * 0.2,
                                 trefoil_size * cos(3.0 * t) * cos(t) + sin(t) * 0.2,
                                 33.0 + 30.0 * sin(t * 0.5));
    }
}

// --- PAUSE SHADERTOY COPYPASTA


void main()
{
  ivec2 iuv = ivec2(gl_GlobalInvocationID.xy);

  // TODO: Put your shadertoy code here!

  // --- CONTINUE SHADERTOY COPYPASTA
  positionSpheres();

  vec2 uv = (iuv - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);

  vec3 camera = vec3(0, 0, -1);
  vec3 ray = normalize(vec3(uv, 0) - camera);
  vec3 surface_point;
  vec3 color;
  if (traceRay(ray, camera, surface_point)) {
      vec3 base = base_color(surface_point);
      color = specular(camera, surface_point, base) + diffuse(surface_point, base) + background_color * base * 0.5;
  } else {
      color = background_color;
  }
  
  imageStore(resultImage, iuv, vec4(color, 1));

  // --- END SHADERTOY COPYPASTA

  /* --- DEFAULT CODE COMMENTED ---
  // Simple gradient as a test.
  vec3 color = vec3(vec2(uv) / vec2(1280, 720), 0);

  if (uv.x < 1280 && uv.y < 720)
    imageStore(resultImage, uv, vec4(color, 1));
  */
}
