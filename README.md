# Компьютерная графика
Репозиторий с материалами для курса компьютерной графики.
Содержимое исторически имеет корни в репозитории [vk_graphics_basic](https://github.com/msu-graphics-group/vk_graphics_basic), однако на данный момент почти весь код был переписан практически с нуля.


## Начало работы
Для начала работы требуется установка достаточно свежих версий [Vulkan SDK](https://vulkan.lunarg.com) (1.3.275+) и [CMake](https://cmake.org/) (3.30+).
Если вы способны самостоятельно установить их, можете смело пропускать следующие 2 подраздела.

### Windows
Мы живём в удивительное время, поэтому на Windows для установки CMake достаточно написать в консоль команду `winget install cmake`, либо `winget upgrade cmake` если вы уже устанавливали его до этого.
Если у вас нет `winget`, установите его.
Как альтернатива -- можно скачать и установить CMake 3.30+ руками с сайта: https://cmake.org/download.

Vulkan SDK же в пакетах winget слишком старой версии, поэтому рекомендуется скачать его с сайта LunarG: https://vulkan.lunarg.com/sdk/home#windows.

### Linux-based
CMake 3.30 слишком новый для не bleeding-edge дистрибутивов, поэтому на Ubuntu вам придётся добавить репозиторий Kitware по инструкции с https://apt.kitware.com и только после этого произнести заветное заклинание `apt install cmake`.
На Arch же `pacman -S cmake` сразу поставит достаточно свежую версию.
Согласно информации из проверенных источников, сломать себе систему установив более свежую версию CMake чем есть в репозиториях дистрибутива **не возможно**.
На других дистрибутивах предлагается разбираться самостоятельно, как вариант, оказывается, самый свежий CMake можно установить [через pip](https://pypi.org/project/cmake/).

Vulkan SDK ставится на Ubuntu аналогично, через добавление репозитория LunarG: https://vulkan.lunarg.com/sdk/home#linux.
На Arch вновь есть готовый пакет, `vulkan-devel` (не проверялось).
На других дистрибутивах придётся ставить через tarball архив с сайта.

### Кэш для зависимостей (опционально, но рекомендовано)
По умолчанию, зависимости будут скачаны в папку билда проекта.
Если вы когда-либо собирали другие проекты, использующие CPM.cmake, может получиться казус, одни и те же зависимости будут перекачиваться по 10 раз.
Чтобы избежать этого, рекомендуется установить переменную окружения `CPM_SOURCE_CACHE` на какую-нибудь папку для хранения зависимостей.
На Linux-based системах для этого достаточно написать `export CPM_SOURCE_CACHE=$HOME/.cache/CPM` в `~/.profile` (или аналог в зависимости от вашего login shell, например `~/.zprofile` для zsh).
На Windows это делается при помощи утилиты "Edit the system environment variables".

### Сборка и запуск
Далее достаточно открыть папку репозитория в вашем любимом редакторе с поддержкой CMake-проектов (Vscode, Visual Studio, Clion, ...), либо сконфигурировать проект при помощи CMake вручную в папку `build`, и вуаля.
Зависимости подкачиваются автоматически при помощи [CPM.cmake](https://github.com/cpm-cmake/CPM.cmake), семплы находящиеся в папке `samples` должны собираться и работать из коробки на Windows и основанных на Linux системах.


## Задания
Задания находятся в папке [tasks](tasks/).
Выполнять их наперёд не следует, так как до объявления доступности следующей домашки их описание и содержимое может меняться произвольным образом.


## Про Вулкан
Так как "сырой" вулкан невероятно неудобен в использовании благодаря заслугам языка C, в данном курсе мы используем официальные "обёртки" над Вулканом для языка C++, `vulkan.hpp`.
Их использование позволяет избежать траты времени на совсем уж глупые баги, делает код короче и эргономичнее.
Так как даже с использованием `vulkan.hpp` Вулкан &mdash; крайне сложное API, мы используем свою тонкую прослойку над ним, [Etna](https://github.com/alexandrShcherbakov/etna/).
Этна автоматизирует различные типовые сценарии работы с Вулканом: создание ресурсов, биндинг их в шейдера, управление свопчейном, синхронизация in-flight кадров, и так далее.
В частности, Этна использует [Vulkan Memory Allocator](https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator) для выделения памяти и [SPIRV Reflect](https://github.com/KhronosGroup/SPIRV-Reflect) для получения мета-информации о шейдерах на стороне C++ во избежание дублирования информации на двух разных языках.
Стоит отметить, что Этна рассчитана на создание демок и семплов, а поэтому никогда не будет иметь внутри себя рендер-граф, систему стриминга и другой подобный функционал "больших движков".

Конечно же есть сценарии работы, не поддержанные в Этне "из коробки".
Для таких случаев рекомендуется либо котрибьютить в Этну новый функционал, либо смело копипастить куски этны в свой код и менять их как душе угодно.
Этна не является полноценной обёрткой над Вулканом, а лишь призвана упростить жизнь и уменьшить количество бойлерплейта в коде!
Для успешного выполнения домашек всё равно придётся понять, как работает Вулкан под капотом!


## Про формат сцен
Для работы со сценами и моделями используется открытый формат [glTF](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html), спецификация которого является простой и понятной, и в следствии чего рекомендуется к точечному прочтению при работе с моделями.
Для загрузки сцен используется [tinygltf](https://github.com/syoyo/tinygltf), который в свою очередь использует [STB](https://github.com/nothings/stb) для загрузки текстур.


## Про другие зависимости
Для взаимодействия с оконным API операционной системы используется [GLFW](https://github.com/glfw/glfw).
Для логирования используется [spdlog](https://github.com/gabime/spdlog), и соответственно для форматирования [fmt](https://github.com/fmtlib/fmt) так как поддержка `std::format` в компиляторах всё ещё оставляет желать лучшего.
Для малоразмерной линейной алгебры используется [glm](https://github.com/g-truc/glm).
Для создания простых дебажных интерфейсов используется [Dear ImGui](https://github.com/ocornut/imgui).
В качестве типобезопасной замены `std::function` используется [function2](https://github.com/Naios/function2).


## Про систему сборки
Для компиляции шейдеров используется CMake.
При сборки любого семпла шейдера собираются автоматически, а также в семплах реализован hot-reload шейдеров по кнопке.
При компиляции таргетов пути до папок с различными ресурсами (скомпилированные шейдера, сцены) "вшиваются" прямо в плюсовый код при помощи дефайнов.
Это означает, что запускаемые файлы семплов **нельзя** куда-то переложить и рассчитывать, что оно будет работать.
Обязательно нужно чтобы при запуске все требуемые ресурсы находились по тем абсолютным путям, по которым они лежали во время компиляции.
Однако эту проблему можно при желании побороть при помощи cmake install и различных хитростей.
Пулл-реквесты приветствуются, но для учебных целей текущих возможностей должно быть достаточно.


## Ассеты
3D-модели используемые для тестов предоставляются с соответствующими лицензиями и атрибуциями, см. директории конкретных сцен.

